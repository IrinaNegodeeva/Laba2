  AREA |.text|, CODE, READONLY

array_sum_asm	PROC	; Начало функции array_sum_asm
	EXPORT array_sum_asm
; Функция (процедура) реализует суммирование массива 
; Функция принимает указатель на массив через регистр R0
; размер массива через регистр R1.
; Результат работы функции возвращается через регистр R0
; R0 = *array
; R1 = size(array)
; return R0 = sum_array
	MOV R3, #0	           ; R3 = "i" = 0 - элемент массива
    MOV R4, #0             ; R4 = 0 - обнуление регистра R3
    MOV R5, #0             ; R5 = "sn" = 0 - сумма отрицательных элементов
    MOV R6, #0             ; R6 = "n" = 0 - кол-во отрицательных элементов
    MOV R7, #4         	   ; Размер одного элемента массива = 4 байтам, 
	MUL R1, R7	           ; Поэтому умножаем кол-во элементов массива на 4.

CVTR                       ; Метка CVTR
    CMP R3, R1             ; Проверка "i" с "masive_size"
    BLT CAJ                ; Если i < masive_size, переход в "CAJ"
    B SRZN                 ; Безусловный переход в "SRZN" - выполняется только, когда не произошел переход в "CAJ"
    
CAJ                        ; Метка CAJ
; Запись в регистр "R3" значения по адресу сохранённом в "R2" 
    LDRB R4, [R0, R3]      ; R4 = mas[i] 
    SXTB R4, R4            ; Расширение знака
    CMP R4, #0             ; Сравнить mas[i] с 0
    BLT JNT                ; Если mas[i] < 0, то переходим в JNT
    B OUTXX                ; Безусловный переход в OUTXX
    
JNT                        ; Метка JNT
    SXTB R5, R5            ; Расширение знака
    ADD R5, R4             ; sn = sn + mas[i]
    ADD R6, #1             ; n = n + 1

OUTXX                      ; Метка OUTXX
    ADD R3, #1             ; i = i + 1
    ADD R3, #4
    B CVTR                 ; Переход в начало подпрограммы
    
; Среднее арифметическое
    CMP R6, #0             ; Сравнение n с нулем
    BNE SRZN               ; Если не равно нулю, то переход в SRZN 
    B OUTEX                ; Иначе переход в OUTEX
SRZN                       ; Метка SRZN
    SDIV R5, R5, R6        ; Среднее арифм.
       
; Записать значение результата в регистр "R0"
OUTEX                      ; Метка OUTEX
    SXTB R0, R0            ; Расширение знака
    MOV R0, R5             ; Запись R5 в R0

    BX LR                  ; Возвращение по адресу, сохраненном в LR
    ENDP                   ; Конец подпрограммы array_sum_asm

;******************************************************************
find_min_func PROC
    EXPORT find_min_func
; Функция (процедура) реализует обработку массива в соответствии с заданием 
; Функция принимает указатель на массив через регистр R0,
; размер массива через регистр R1,
; указатель на пустой массив через регистр R2
; R0 = *array
; R1 = size(array)
; R2 = *new_array	
    MOV R3, #0             ; R3 = "i" = 0 - элемент массива
    MOV R4, #0             ; R4 = 0 - обнуление регистра R3   
    MOV R5, #0             ; R5 = "nm" = 0 - наименьший элемент
    MOV R6, #4 	           ; Размер одного элемента массива = 4 байтам, 
	MUL R1, R6	           ; Поэтому умножаем кол-во элементов массива на 4.
    
KYTR                       ; Метка KYTR
    CMP R3, R1             ; Проверка "i" c "masive_size"
    BLT CAT                ; Если i < MAX_size, переход в "CAT"
    B OUTEXX               ; Безусловный переход в "OUTEXX" - выполняется только, когда не произошел переход в "CAT"
    
CAT                        ; Метка CAT
; Запись в регистр "R3" значения по адресу сохранённом в "R2" 
    LDRB R4, [R0, R3]      ; R4 = mas[i] 
    SXTB R4, R4            ; Расширение знака
    CMP R4, #0             ; Сравнить mas[i] с 0
    BLT LKJ                ; Если mas[i] < 0, то переходим в LKJ
    B OUTXXX               ; Безусловный переход в OUTXXX
        
LKJ                        ; Метка LKJ
    CMP R4, R5             ; Сравнение mas[i] с nm
    BLE SRAW               ; Если mas[i] < nm, то переход в SRAW
    B OUTXXX               ; Иначе переход в OUTXXX
    
SRAW                       ; Метка SRAW
    MOV R5, R4             ; Запись R5 = R4, присвоили R5 Титул элемента с минимальным значением

OUTXXX                     ; Метка OUTXX
    ADD R3, #1             ; i = i + 1
    ADD R3, #4
    B KYTR                 ; Переход в начало подпрограммы

OUTEXX                     ; Метка OUTEXX
    SXTB R0, R0
    MOV R0, R5             ; Запись R5 в R0

    BX LR                  ; Возвращение по адресу, сохраненном в LR
    ENDP                   ; Конец ПП find_min_func
        
;******************************************************************
var_5	PROC	; Начало функции array_treatment_asm
	EXPORT var_5
; Функция (процедура) реализует обработку массива в соответствии с заданием 
; Функция принимает указатель на массив через регистр R0,
; размер массива через регистр R1,
; указатель на пустой массив через регистр R2
; R0 = *array
; R1 = size(array)
; R2 = *new_array	
    PUSH {LR}
	MOV R3, #0	; R3 = "i" = 0 - элемент массива
;	MOV R4, #0	; R4 = 0 - средн. арифм. отриц. элементов массива
	
; Вызываем процедуру вычисления средн. арифм. отриц. эл. массива
	PUSH {R0-R4, LR}	    ; Записываем все необходимые регистры в стек, необходимые для процедуры array_treatment_asm
; в регистрах R0 и R1 уже лежит необходимые данные для вычисления суммы
	BL array_sum_asm
	MOV R4, R0			    ; Запись суммы массива в регистр R4
    STR R4, [R4]            ; Соханение содержимого регистра R4 в памяти по адресу в регистре R4
	POP {R0-R4, LR}		    ; возвращаем записанные ранее регистры из стека
		
; Вызываем процедуру поиска минимального элемента массива
	PUSH {R0-R7, LR}	    ; Записываем все необходимые регистры в стек, необходимые для процедуры array_treatment_asm
; в регистрах R0 и R1 уже лежит необходимые данные для вычисления суммы
	BL find_min_func
	MOV R7, R0			    ; Запись суммы массива в регистр R4
    STR R7, [R7]            ; Соханение содержимого регистра R4 в памяти по адресу в регистре R4
	POP {R0-R7, LR}		    ; возвращаем записанные ранее регистры из стека
	    
    POP {LR}
    BX LR


;	MOV R5, #4 	; Размер одного элемента массива = 4 байтам, 
;	MUL R1, R5	; поэтому умножаем кол-во элементов массива на 4.

;;При выполнении задачи происходит деление на ноль при заполнении первого элемента. 
;;Поэтому мы запишем в нулевой элемент массива максимальное число типа int32_t = 2 147 483 647
;	MOV R5, #2147483647
;	STR R5, [R2,R3]

;	ADD R3, #4 ; смещаем относительный адрес массива

;treatment
;	CMP R3,R1	; Проверка R3 > R1
;	BLT treatment_calc	; Если R2 < R1, переходим в "CALС"
;	B exit_treatment	; Eсли R2 > R1, выходим из программы
;	
;treatment_calc
;	
;	ASR R6, R3, #2
;	SDIV R5, R4, R6
;	STR R5, [R2,R3]
;	ADD R3,#4 ; смещаем относительный адрес массива
;	B treatment
;	
;exit_treatment
;	BX LR	; Возвращаемся назад по адресу расположенному в регистре LR
;	ENDP	; Конец функции array_treatment_asm

	END		                ; Конец файла